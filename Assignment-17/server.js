// server.js
import express from "express";
import bodyParser from "body-parser";
import fs from "fs";
import path from "path";
import dotenv from "dotenv";
import puppeteer from "puppeteer";
import { GoogleGenAI } from "@google/genai";

dotenv.config();

const PORT = process.env.PORT || 3000;
const app = express();
app.use(bodyParser.json());

// initialize Gemini client (SDK picks API key from GEMINI_API_KEY env var)
const ai = new GoogleGenAI({});

// Helper: build prompt asking for a strict JSON response
function buildGeminiPrompt(ingredients) {
  const ingrList = ingredients.join(", ");
  return `
You are a helpful chef and recipe writer. Given the ingredients below, produce a complete recipe in JSON only (no extra text).
Ingredients: [${ingrList}]

Respond with a JSON object with these fields:
{
  "title": "<creative recipe title>",
  "ingredients": [
    {"name":"chicken","quantity":"250 g"},
    ...
  ],
  "steps": [
    "Step 1: ...",
    ...
  ],
  "nutrition": {
    "calories": "430 kcal",
    "protein": "35 g",
    "fat": "18 g",
    "carbs": "5 g"
  } // optional - if not able to estimate, return null
}

Requirements:
- Provide at least 5 numbered steps in "steps".
- Quantities should be realistic and in common cooking units (g, ml, cup, tbsp, tsp, cloves, pcs).
- Make steps user-friendly and concise (1-2 sentences each).
- If nutrition is included, return estimated numeric values with units.
- Output must be valid JSON only (no markdown, no explanatory text).
`;
}

// Convert the parsed recipe object into styled HTML for PDF
function recipeToHTML(recipe) {
  const ingredientsHtml = recipe.ingredients
    .map((i) => `<li>${i.name} â€” ${i.quantity}</li>`)
    .join("");
  const stepsHtml = recipe.steps.map((s) => `<li>${s}</li>`).join("");
  const nutritionHtml = recipe.nutrition
    ? `<p><strong>Nutrition (estimate):</strong> ${recipe.nutrition.calories} | ${recipe.nutrition.protein} | ${recipe.nutrition.fat} | ${recipe.nutrition.carbs}</p>`
    : "";
  return `
  <!doctype html>
  <html>
  <head>
    <meta charset="utf-8"/>
    <title>${escapeHtml(recipe.title)}</title>
    <style>
      body { font-family: Arial, sans-serif; padding: 28px; line-height: 1.4; }
      .card { max-width: 800px; margin: auto; border-radius: 8px; padding: 24px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); }
      h1 { margin-bottom: 4px; font-size: 28px; }
      h2 { margin-top: 20px; font-size: 18px; }
      ul { margin-left: 20px; }
      .meta { color: #555; margin-bottom: 12px; }
    </style>
  </head>
  <body>
    <div class="card">
      <h1>${escapeHtml(recipe.title)}</h1>
      <div class="meta">Generated by Gemini</div>

      <h2>Ingredients</h2>
      <ul>${ingredientsHtml}</ul>

      <h2>Steps</h2>
      <ol>${stepsHtml}</ol>

      ${nutritionHtml}
    </div>
  </body>
  </html>
  `;
}

function escapeHtml(unsafe) {
  return (unsafe || "")
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;");
}

// Main route: accept ingredient list, call Gemini, return PDF
app.post("/generate-recipe", async (req, res) => {
  try {
    const { ingredients } = req.body;
    if (!Array.isArray(ingredients) || ingredients.length === 0) {
      return res
        .status(400)
        .json({ error: "Provide an 'ingredients' array in JSON body." });
    }

    const prompt = buildGeminiPrompt(ingredients);

    // Call Gemini API (generateContent). model can be "gemini-2.5-flash" or other available model.
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: prompt,
      // optionally: config: { thinkingConfig: { thinkingBudget: 0 } } to reduce "thinking" cost.
    });

    const text =
      response.text?.trim?.() ??
      response?.candidates?.[0]?.content?.parts?.[0]?.text;
    if (!text) {
      return res.status(500).json({ error: "No response from Gemini." });
    }

    // Parse JSON from Gemini: it *should* return pure JSON per our prompt.
    let recipe;
    try {
      recipe = JSON.parse(text);
    } catch (err) {
      // If Gemini returned extra text, try to extract JSON block
      const match = text.match(/\{[\s\S]*\}$/);
      if (match) recipe = JSON.parse(match[0]);
      else throw new Error("Failed to parse JSON from Gemini response");
    }

    // Build HTML and generate PDF
    const html = recipeToHTML(recipe);
    const tmpHtmlPath = path.join(process.cwd(), "tmp_recipe.html");
    const tmpPdfPath = path.join(process.cwd(), `recipe_${Date.now()}.pdf`);
    fs.writeFileSync(tmpHtmlPath, html, "utf8");

    const browser = await puppeteer.launch({
      args: ["--no-sandbox", "--disable-setuid-sandbox"],
    });
    const page = await browser.newPage();
    await page.goto("file://" + tmpHtmlPath, { waitUntil: "networkidle0" });
    await page.pdf({
      path: tmpPdfPath,
      format: "A4",
      printBackground: true,
      margin: { top: "20px", bottom: "20px" },
    });
    await browser.close();

    // Send PDF as download & JSON summary
    res.download(
      tmpPdfPath,
      `${slugify(recipe.title || "recipe")}.pdf`,
      (err) => {
        // cleanup files
        try {
          fs.unlinkSync(tmpHtmlPath);
        } catch (e) {}
        try {
          fs.unlinkSync(tmpPdfPath);
        } catch (e) {}
      }
    );
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: err.message || "Server error" });
  }
});

function slugify(text) {
  return (text || "recipe")
    .toString()
    .toLowerCase()
    .replace(/\s+/g, "-")
    .replace(/[^\w\-]+/g, "")
    .replace(/\-\-+/g, "-");
}

app.listen(PORT, () =>
  console.log(
    `Gemini-only Recipe Generator running on http://localhost:${PORT}`
  )
);
